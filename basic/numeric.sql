-- basic

-- NUMERIC
SELECT 'SMALLINT/INT/BIGINT' as integeres;
SELECT (-32768)::smallint as smallint,
     32767::smallint as smallint;
SELECT (-2147483648)::int as int,
     2147483647::int as int;
SELECT  (-9223372036854775808)::bigint as bigint,
     9223372036854775807::bigint as bigint;

SELECT 'NUMERIC/DECIMAL 131072 digits before point; up to 16383 digits point' as fixed_point;

SELECT 131072.16383::decimal as decimal,
    131072.16383::decimal(1000) as decimal,
    131072.16383::decimal(1000,10) as decimal;
SELECT   131072.16383::numeric as numeric,
    131072.16383::numeric(1000) as numeric,
    131072.16383::numeric(1000,10) as numeric;
-- can consume considerably more space than the floating-point types

SELECT 'REAL 6 decimal digits precision DOUBLE 15 decimal digits precision' as floating_point;
SELECT 6.6::real as real,
    6.6::real as real,
    15.15::decimal as decimal,
    15.15::decimal as decimal;

SELECT 'NUMERIC rounds to zero' as round;
SELECT x,
  round(x::numeric) AS numeric_round,
  round(x::double precision) AS double_round,
  round(x::real) AS real_round,
  round(x::float) AS float_round
FROM generate_series(-3.5, 3.5, 1) as x;

-- Use integers when possible.

-- If you’re working with decimal data and need calculations to be exact (dealing with money, for example), choose numeric/decimal.

-- Float types will save space, but the inexactness of floating-point math won’t pass muster in many applications. Use them only when exactness is not as important.

-- Choose a big enough number type. When using numeric or decimal, set the precision large enough to accommodate the number of digits on both sides of the decimal point.
-- With whole numbers, use bigint unless you’re absolutely sure column values will be constrained to fit into the smaller integer or smallint type.

DROP TABLE IF EXISTS serial_table;
CREATE TABLE serial_table (
    small_id smallserial,
    id serial,
    big_id bigserial
);

ALTER SEQUENCE serial_table_small_id_seq
RESTART WITH 32767;

ALTER SEQUENCE serial_table_id_seq
RESTART WITH 2147483647;

ALTER SEQUENCE serial_table_big_id_seq
RESTART WITH 9223372036854775807;

INSERT INTO serial_table VALUES(DEFAULT, DEFAULT, DEFAULT);
INSERT INTO serial_table VALUES(DEFAULT, DEFAULT, DEFAULT);
SELECT 'SERIAL allows to insert non-default values' AS serial;
INSERT INTO serial_table VALUES(1, 1, 1);

-- While a table using a serial column requires the INSERT privilege on the table and the USAGE privilege on the underlying sequence this is not needed for tables using an identity columns. Granting the INSERT privilege is enough.
DROP TABLE IF EXISTS generate_table;
CREATE TABLE generate_table (
    gen_id bigint GENERATED ALWAYS AS IDENTITY
);
INSERT INTO generate_table(gen_id) VALUES (DEFAULT);
INSERT INTO generate_table(gen_id) VALUES (2);
-- GENERATED BY DEFAULT AS IDENTITY

-- ABS ACOS ASIN ATAN CEIL COS COT EXP FLOOR LN LOG
SELECT FLOOR(3.141618);
SELECT LOG(2,65536);
-- MOD
SELECT PI();
SELECT POWER(2, 10);
-- RADIANS RAND ROUND SIGN SIN SUM
SELECT SQRT(2);
--TAN
SELECT ROUND((SELECT PI()));
SELECT SIGN((SELECT PI()));

SELECT CAST(2.0 AS real);
SELECT 2::decimal;




